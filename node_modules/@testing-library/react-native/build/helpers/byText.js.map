{"version":3,"sources":["../../src/helpers/byText.ts"],"names":["getChildrenAsText","children","TextComponent","textContent","React","Children","forEach","child","push","toString","props","Fragment","getNodeByText","node","text","options","Text","require","isTextComponent","textChildren","textToTest","join","exact","normalizer","error","queryAllByText","instance","queryAllByTextFn","queryOptions","results","findAll","getMultipleError","String","getMissingError","getBy","getByText","getAllBy","getAllByText","queryBy","queryByText","findBy","findByText","findAllBy","findAllByText"],"mappings":";;;;;;;AACA;;AACA;;AAEA;;AAEA;;AACA;;;;;;AAOA,MAAMA,iBAAiB,GAAG,CACxBC,QADwB,EAExBC,aAFwB,KAGrB;AACH,QAAMC,WAAqB,GAAG,EAA9B;AACAC,EAAAA,KAAK,CAACC,QAAN,CAAeC,OAAf,CAAuBL,QAAvB,EAAkCM,KAAD,IAAW;AAAA;;AAC1C,QAAI,OAAOA,KAAP,KAAiB,QAArB,EAA+B;AAC7BJ,MAAAA,WAAW,CAACK,IAAZ,CAAiBD,KAAjB;AACA;AACD;;AAED,QAAI,OAAOA,KAAP,KAAiB,QAArB,EAA+B;AAC7BJ,MAAAA,WAAW,CAACK,IAAZ,CAAiBD,KAAK,CAACE,QAAN,EAAjB;AACA;AACD;;AAED,QAAIF,KAAJ,aAAIA,KAAJ,+BAAIA,KAAK,CAAEG,KAAX,yCAAI,aAAcT,QAAlB,EAA4B;AAC1B;AACA;AACA;AACA;AACA,UAAI,wCAAiBM,KAAjB,EAAwBL,aAAxB,CAAJ,EAA4C;AAC1C;AACD;;AAED,UAAI,wCAAiBK,KAAjB,EAAwBH,KAAK,CAACO,QAA9B,CAAJ,EAA6C;AAC3CR,QAAAA,WAAW,CAACK,IAAZ,CACE,GAAGR,iBAAiB,CAACO,KAAK,CAACG,KAAN,CAAYT,QAAb,EAAuBC,aAAvB,CADtB;AAGD;AACF;AACF,GA1BD;AA4BA,SAAOC,WAAP;AACD,CAlCD;;AAoCA,MAAMS,aAAa,GAAG,CACpBC,IADoB,EAEpBC,IAFoB,EAGpBC,OAAyB,GAAG,EAHR,KAIjB;AACH,MAAI;AACF,UAAM;AAAEC,MAAAA;AAAF,QAAWC,OAAO,CAAC,cAAD,CAAxB;;AACA,UAAMC,eAAe,GAAG,wCAAiBL,IAAjB,EAAuBG,IAAvB,CAAxB;;AACA,QAAIE,eAAJ,EAAqB;AACnB,YAAMC,YAAY,GAAGnB,iBAAiB,CAACa,IAAI,CAACH,KAAL,CAAWT,QAAZ,EAAsBe,IAAtB,CAAtC;;AACA,UAAIG,YAAJ,EAAkB;AAChB,cAAMC,UAAU,GAAGD,YAAY,CAACE,IAAb,CAAkB,EAAlB,CAAnB;AACA,cAAM;AAAEC,UAAAA,KAAF;AAASC,UAAAA;AAAT,YAAwBR,OAA9B;AACA,eAAO,sBAAQD,IAAR,EAAcM,UAAd,EAA0BG,UAA1B,EAAsCD,KAAtC,CAAP;AACD;AACF;;AACD,WAAO,KAAP;AACD,GAZD,CAYE,OAAOE,KAAP,EAAc;AACd,UAAM,4CAA+BA,KAA/B,CAAN;AACD;AACF,CApBD;;AAsBA,MAAMC,cAAc,GAClBC,QADqB,IAMrB,SAASC,gBAAT,CAA0Bb,IAA1B,EAAgCc,YAAhC,EAA8C;AAC5C,QAAMC,OAAO,GAAGH,QAAQ,CAACI,OAAT,CAAkBjB,IAAD,IAC/BD,aAAa,CAACC,IAAD,EAAOC,IAAP,EAAac,YAAb,CADC,CAAhB;AAIA,SAAOC,OAAP;AACD,CAZH;;;;AAcA,MAAME,gBAAgB,GAAIjB,IAAD,IACtB,sCAAqCkB,MAAM,CAAClB,IAAD,CAAO,EADrD;;AAEA,MAAMmB,eAAe,GAAInB,IAAD,IACrB,wCAAuCkB,MAAM,CAAClB,IAAD,CAAO,EADvD;;AAGA,MAAM;AACJoB,EAAAA,KAAK,EAAEC,SADH;AAEJC,EAAAA,QAAQ,EAAEC,YAFN;AAGJC,EAAAA,OAAO,EAAEC,WAHL;AAIJC,EAAAA,MAAM,EAAEC,UAJJ;AAKJC,EAAAA,SAAS,EAAEC;AALP,IAMkB,8BACtBlB,cADsB,EAEtBQ,eAFsB,EAGtBF,gBAHsB,CANxB","sourcesContent":["import type { ReactTestInstance } from 'react-test-renderer';\nimport * as React from 'react';\nimport { matches, TextMatch } from '../matches';\nimport type { NormalizerFn } from '../matches';\nimport { makeQueries } from './makeQueries';\nimport type { Queries } from './makeQueries';\nimport { filterNodeByType } from './filterNodeByType';\nimport { createLibraryNotSupportedError } from './errors';\n\nexport type TextMatchOptions = {\n  exact?: boolean;\n  normalizer?: NormalizerFn;\n};\n\nconst getChildrenAsText = (\n  children: React.ReactChild[],\n  TextComponent: React.ComponentType\n) => {\n  const textContent: string[] = [];\n  React.Children.forEach(children, (child) => {\n    if (typeof child === 'string') {\n      textContent.push(child);\n      return;\n    }\n\n    if (typeof child === 'number') {\n      textContent.push(child.toString());\n      return;\n    }\n\n    if (child?.props?.children) {\n      // Bail on traversing text children down the tree if current node (child)\n      // has no text. In such situations, react-test-renderer will traverse down\n      // this tree in a separate call and run this query again. As a result, the\n      // query will match the deepest text node that matches requested text.\n      if (filterNodeByType(child, TextComponent)) {\n        return;\n      }\n\n      if (filterNodeByType(child, React.Fragment)) {\n        textContent.push(\n          ...getChildrenAsText(child.props.children, TextComponent)\n        );\n      }\n    }\n  });\n\n  return textContent;\n};\n\nconst getNodeByText = (\n  node: ReactTestInstance,\n  text: TextMatch,\n  options: TextMatchOptions = {}\n) => {\n  try {\n    const { Text } = require('react-native');\n    const isTextComponent = filterNodeByType(node, Text);\n    if (isTextComponent) {\n      const textChildren = getChildrenAsText(node.props.children, Text);\n      if (textChildren) {\n        const textToTest = textChildren.join('');\n        const { exact, normalizer } = options;\n        return matches(text, textToTest, normalizer, exact);\n      }\n    }\n    return false;\n  } catch (error) {\n    throw createLibraryNotSupportedError(error);\n  }\n};\n\nconst queryAllByText = (\n  instance: ReactTestInstance\n): ((\n  text: TextMatch,\n  queryOptions?: TextMatchOptions\n) => Array<ReactTestInstance>) =>\n  function queryAllByTextFn(text, queryOptions) {\n    const results = instance.findAll((node) =>\n      getNodeByText(node, text, queryOptions)\n    );\n\n    return results;\n  };\n\nconst getMultipleError = (text: TextMatch) =>\n  `Found multiple elements with text: ${String(text)}`;\nconst getMissingError = (text: TextMatch) =>\n  `Unable to find an element with text: ${String(text)}`;\n\nconst {\n  getBy: getByText,\n  getAllBy: getAllByText,\n  queryBy: queryByText,\n  findBy: findByText,\n  findAllBy: findAllByText,\n}: Queries<TextMatch> = makeQueries(\n  queryAllByText,\n  getMissingError,\n  getMultipleError\n);\n\nexport {\n  findAllByText,\n  findByText,\n  getAllByText,\n  getByText,\n  queryAllByText,\n  queryByText,\n};\n"],"file":"byText.js"}